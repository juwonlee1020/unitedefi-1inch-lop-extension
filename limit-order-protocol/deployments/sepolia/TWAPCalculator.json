{
  "address": "0xEF8bBdF7955E8101d52e3f09144462f86bAeA5e0",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidPrice",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RequestedExceedsUnlocked",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "takingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingMakingAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "getMakingAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "makerAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "makingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingMakingAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "getTakingAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "takerAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x194345d916b7be673f309ad42e322ca73b1a3a046948b392cec7904d45ed7c27",
  "receipt": {
    "to": null,
    "from": "0x11B3C740f6DE96E8781A993db42fBF5147D753A5",
    "contractAddress": "0xEF8bBdF7955E8101d52e3f09144462f86bAeA5e0",
    "transactionIndex": 166,
    "gasUsed": "348781",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2e48440fa93c2e5e1974f3c44262b13a65161550bf0c2b4e3195743c6b673ac9",
    "transactionHash": "0x194345d916b7be673f309ad42e322ca73b1a3a046948b392cec7904d45ed7c27",
    "logs": [],
    "blockNumber": 8856378,
    "cumulativeGasUsed": "14079420",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "a0f29a521064816be59a7e9f0a0c2f64",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestedExceedsUnlocked\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingMakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"getMakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"makerAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingMakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"getTakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"takerAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"TWAPCalculator\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getMakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)\":{\"notice\":\"Called by Fusion to calculate how much makerAsset can be bought for a given takerAsset amount\"},\"getTakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)\":{\"notice\":\"Called by Fusion to calculate the takerAsset amount required for a given makerAsset amount\"}},\"notice\":\"Calculates time-unlocked makerAsset amounts with real-time pricing via Chainlink.         Fully Fusion-compatible and supports arbitrary token decimals via extraData.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/extensions/TWAPCalculator.sol\":\"TWAPCalculator\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype Address is uint256;\\n\\n/**\\n* @notice AddressLib\\n* @notice Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\\n*/\\nlibrary AddressLib {\\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\\n\\n    /**\\n    * @notice Returns the address representation of a uint256.\\n    * @param a The uint256 value to convert to an address.\\n    * @return The address representation of the provided uint256 value.\\n    */\\n    function get(Address a) internal pure returns (address) {\\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\\n    }\\n\\n    /**\\n    * @notice Checks if a given flag is set for the provided address.\\n    * @param a The address to check for the flag.\\n    * @param flag The flag to check for in the provided address.\\n    * @return True if the provided flag is set in the address, false otherwise.\\n    */\\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\\n        return (Address.unwrap(a) & flag) != 0;\\n    }\\n\\n    /**\\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint32 value.\\n    * @param offset The bit offset at which the uint32 value is stored.\\n    * @return The uint32 value stored in the address at the specified bit offset.\\n    */\\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\\n        return uint32(Address.unwrap(a) >> offset);\\n    }\\n\\n    /**\\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint64 value.\\n    * @param offset The bit offset at which the uint64 value is stored.\\n    * @return The uint64 value stored in the address at the specified bit offset.\\n    */\\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\\n        return uint64(Address.unwrap(a) >> offset);\\n    }\\n}\\n\",\"keccak256\":\"0xe860b410ed5371b9732daab80982eef0a42ae48474716a89725ca744e27b7d75\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0xfe4e8bb4861bb3860ba890ab91a3b818ec66e5a8f544fb608cfcb73f433472cd\",\"license\":\"MIT\"},\"contracts/extensions/TWAPCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/IAmountGetter.sol\\\";\\nimport \\\"../interfaces/IOrderMixin.sol\\\";\\n\\n/// @title TWAPCalculator\\n/// @notice Calculates time-unlocked makerAsset amounts with real-time pricing via Chainlink.\\n///         Fully Fusion-compatible and supports arbitrary token decimals via extraData.\\ncontract TWAPCalculator is IAmountGetter {\\n    error RequestedExceedsUnlocked();\\n    error InvalidPrice();\\n\\n    /// @notice Called by Fusion to calculate the takerAsset amount required for a given makerAsset amount\\n    function getTakingAmount(\\n        IOrderMixin.Order calldata,     // order (unused)\\n        bytes calldata,                 // extension (unused)\\n        bytes32,                        // orderHash (unused)\\n        address,                        // taker (unused)\\n        uint256 makingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view override returns (uint256 takerAmount) {\\n        (\\n            uint256 startTime,\\n            uint256 interval,\\n            uint256 chunkAmount,\\n            uint256 totalAmount,\\n            address priceFeed,\\n            uint8 makerDecimals,\\n            uint8 takerDecimals\\n        ) = abi.decode(extraData, (uint256, uint256, uint256, uint256, address, uint8, uint8));\\n\\n        uint256 unlocked = _getUnlockedAmount(startTime, interval, chunkAmount, totalAmount);\\n        uint256 available = _min(unlocked, remainingMakingAmount);\\n        if (makingAmount > available) revert RequestedExceedsUnlocked();\\n\\n        uint256 price = _getLatestPrice(priceFeed); // 8 decimals from Chainlink\\n        uint256 scale = 10 ** (makerDecimals + 8 - takerDecimals); // normalize output\\n        takerAmount = price * makingAmount / scale;\\n    }\\n\\n    /// @notice Called by Fusion to calculate how much makerAsset can be bought for a given takerAsset amount\\n    function getMakingAmount(\\n        IOrderMixin.Order calldata,     // order (unused)\\n        bytes calldata,                 // extension (unused)\\n        bytes32,                        // orderHash (unused)\\n        address,                        // taker (unused)\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view override returns (uint256 makerAmount) {\\n        (\\n            uint256 startTime,\\n            uint256 interval,\\n            uint256 chunkAmount,\\n            uint256 totalAmount,\\n            address priceFeed,\\n            uint8 makerDecimals,\\n            uint8 takerDecimals\\n        ) = abi.decode(extraData, (uint256, uint256, uint256, uint256, address, uint8, uint8));\\n\\n        uint256 price = _getLatestPrice(priceFeed); // 8 decimals\\n        uint256 scale = 10 ** (makerDecimals + 8 - takerDecimals);\\n        makerAmount = takingAmount * scale / price;\\n\\n        uint256 unlocked = _getUnlockedAmount(startTime, interval, chunkAmount, totalAmount);\\n        uint256 available = _min(unlocked, remainingMakingAmount);\\n        if (makerAmount > available) revert RequestedExceedsUnlocked();\\n\\n        // Round down to nearest chunk\\n        uint256 chunks = makerAmount / chunkAmount;\\n        makerAmount = chunks * chunkAmount;\\n    }\\n\\n    /// @dev Internal helper to get how much makerAsset is currently unlocked\\n    function _getUnlockedAmount(\\n        uint256 startTime,\\n        uint256 interval,\\n        uint256 chunkAmount,\\n        uint256 totalAmount\\n    ) internal view returns (uint256) {\\n        if (block.timestamp < startTime) return 0;\\n\\n        uint256 elapsed = block.timestamp - startTime;\\n        uint256 chunksUnlocked = elapsed / interval;\\n        uint256 unlocked = chunksUnlocked * chunkAmount;\\n\\n        return unlocked > totalAmount ? totalAmount : unlocked;\\n    }\\n\\n    /// @dev Internal helper to fetch the latest price from Chainlink\\n    function _getLatestPrice(address priceFeed) internal view returns (uint256) {\\n        (, int256 price,,,) = AggregatorV3Interface(priceFeed).latestRoundData();\\n        if (price <= 0) revert InvalidPrice();\\n        return uint256(price);\\n    }\\n\\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x6712b05272bca1341ad78d6e612fab7cd42eee3a86fe6db71a7ab0298536f3c8\",\"license\":\"MIT\"},\"contracts/interfaces/IAmountGetter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOrderMixin.sol\\\";\\n\\n/**\\n * @title IAmountGetter\\n * @notice Interface for external logic to determine actual making and taking amounts for orders.\\n */\\ninterface IAmountGetter {\\n    /**\\n     * @notice View method that gets called to determine the actual making amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param takingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return makingAmount Actual making amount that should be used for the order\\n     */\\n    function getMakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice View method that gets called to determine the actual taking amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param makingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return takingAmount Actual taking amount that should be used for the order\\n     */\\n    function getTakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd2f5f477d812411a2eee26d645cd096b256221862fcf4a004128f7bdd43a6e08\",\"license\":\"MIT\"},\"contracts/interfaces/IOrderMixin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport \\\"../libraries/MakerTraitsLib.sol\\\";\\nimport \\\"../libraries/TakerTraitsLib.sol\\\";\\n\\n/**\\n * @title IOrderMixin\\n * @notice Interface for order processing logic in the 1inch Limit Order Protocol.\\n */\\ninterface IOrderMixin {\\n    struct Order {\\n        uint256 salt;\\n        Address maker;\\n        Address receiver;\\n        Address makerAsset;\\n        Address takerAsset;\\n        uint256 makingAmount;\\n        uint256 takingAmount;\\n        MakerTraits makerTraits;\\n    }\\n\\n    error InvalidatedOrder();\\n    error TakingAmountExceeded();\\n    error PrivateOrder();\\n    error BadSignature();\\n    error OrderExpired();\\n    error WrongSeriesNonce();\\n    error SwapWithZeroAmount();\\n    error PartialFillNotAllowed();\\n    error OrderIsNotSuitableForMassInvalidation();\\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\\n    error ReentrancyDetected();\\n    error PredicateIsNotTrue();\\n    error TakingAmountTooHigh();\\n    error MakingAmountTooLow();\\n    error TransferFromMakerToTakerFailed();\\n    error TransferFromTakerToMakerFailed();\\n    error MismatchArraysLengths();\\n    error InvalidPermit2Transfer();\\n    error SimulationResults(bool success, bytes res);\\n\\n    /**\\n     * @notice Emitted when order gets filled\\n     * @param orderHash Hash of the order\\n     * @param remainingAmount Amount of the maker asset that remains to be filled\\n     */\\n    event OrderFilled(\\n        bytes32 orderHash,\\n        uint256 remainingAmount\\n    );\\n\\n    /**\\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\\n     * @param orderHash Hash of the order\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash\\n    );\\n\\n    /**\\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\\n     * @param maker Maker address\\n     * @param slotIndex Slot index that was updated\\n     * @param slotValue New slot value\\n     */\\n    event BitInvalidatorUpdated(\\n        address indexed maker,\\n        uint256 slotIndex,\\n        uint256 slotValue\\n    );\\n\\n    /**\\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\\n     * @dev The function always reverts and returns the simulation results in revert data.\\n     * @param target Addresses that will be delegated\\n     * @param data Data that will be passed to delegatee\\n     */\\n    function simulate(address target, bytes calldata data) external;\\n\\n    /**\\n     * @notice Cancels order's quote\\n     * @param makerTraits Order makerTraits\\n     * @param orderHash Hash of the order to cancel\\n     */\\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\\n\\n    /**\\n     * @notice Cancels orders' quotes\\n     * @param makerTraits Orders makerTraits\\n     * @param orderHashes Hashes of the orders to cancel\\n     */\\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\\n\\n    /**\\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\\n     * @param makerTraits Order makerTraits\\n     * @param additionalMask Additional bitmask to invalidate orders\\n     */\\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\\n\\n    /**\\n     * @notice Fills order's quote, fully or partially (whichever is possible).\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrder(\\n        Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrderArgs(\\n        IOrderMixin.Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but uses contract-based signatures.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrder(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrderArgs(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param maker Maker address\\n     * @param slot Slot number to return bitmask for\\n     * @return result Each bit represents whether corresponding was already invalidated\\n     */\\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remaining Remaining amount of the order\\n     */\\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\\n     */\\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\\n\\n    /**\\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\\n     * @param order Order\\n     * @return orderHash Hash of the order\\n     */\\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\\n}\\n\",\"keccak256\":\"0x39cfb84ae74a276eae63d7b3be898104045f98163405190227ddae3e85f6dd11\",\"license\":\"MIT\"},\"contracts/libraries/MakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype MakerTraits is uint256;\\n\\n/**\\n * @title MakerTraitsLib\\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\\n * @dev\\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\\n * High bits are used for flags\\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\\n * 253 bit                                  - unused\\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\\n\\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n * uint80 last 10 bytes of allowed sender address (0 if any)\\n * uint40 expiration timestamp (0 if none)\\n * uint40 nonce or epoch\\n * uint40 series\\n */\\nlibrary MakerTraitsLib {\\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\\n    uint256 private constant _EXPIRATION_OFFSET = 80;\\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\\n    uint256 private constant _SERIES_OFFSET = 160;\\n    uint256 private constant _SERIES_MASK = type(uint40).max;\\n\\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\\n\\n    /**\\n     * @notice Checks if the order has the extension flag set.\\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the flag is set.\\n     */\\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker allows a specific taker to fill the order.\\n     * @param makerTraits The traits of the maker.\\n     * @param sender The address of the taker to be checked.\\n     * @return result A boolean indicating whether the taker is allowed.\\n     */\\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the expiration time of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The expiration timestamp of the order.\\n     */\\n    function getExpirationTime(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the order has expired.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the order has expired.\\n     */\\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\\n        uint256 expiration = getExpirationTime(makerTraits);\\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /**\\n     * @notice Returns the nonce or epoch of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The nonce or epoch of the order.\\n     */\\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the series of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The series of the order.\\n     */\\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows partial fills.\\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows partial fills.\\n      */\\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs pre-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\\n     */\\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs post-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\\n     */\\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows multiple fills.\\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows multiple fills.\\n      */\\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the bit invalidator should be used.\\n      * True if the order requires the use of the bit invalidator.\\n      */\\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to check the epoch.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\\n     */\\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker uses permit2.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker uses permit2.\\n     */\\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to unwraps WETH.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\\n     */\\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x9506febc99293a286356a03cb150ad82ccb88be1b4c908183e1273b41fcb902c\",\"license\":\"MIT\"},\"contracts/libraries/TakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype TakerTraits is uint256;\\n\\n/**\\n * @title TakerTraitsLib\\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\\n * @dev The TakerTraits are structured as follows:\\n * High bits are used for flags\\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.\\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker\\u2019s funds transfer.\\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\\n */\\nlibrary TakerTraitsLib {\\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\\n\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\\n\\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Checks if the args should contain target address.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the args should contain target address.\\n     */\\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the extension calldata encoded in the takerTraits.\\n     */\\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the interaction calldata encoded in the takerTraits.\\n     */\\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the taking amount should be calculated based on making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\\n     */\\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order should unwrap WETH.\\n     */\\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should skip maker's permit execution.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order don't apply permit.\\n     */\\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order uses the permit2 instead of permit.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order uses the permit2.\\n     */\\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the threshold amount from the takerTraits.\\n     * The maximum amount a taker agrees to give in exchange for a making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The threshold amount encoded in the takerTraits.\\n     */\\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x144f154a46e8daa0fec5b8215f1d8d3b694cb939236aa7bf89976b27965c2837\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657610561908161001b8239f35b5f80fdfe60a06040526004361015610011575f80fd5b5f3560e01c80631d9671c3146100fd5763d7ff8a801461002f575f80fd5b346100f957610056610062610043366101d4565b945094509695509693505081019061028c565b979490969391956104f2565b90808210156100f257505b84116100c8576020936100b56100b06100c0956100ab6100a573ffffffffffffffffffffffffffffffffffffffff6100bb97166103af565b966102ea565b610329565b61033d565b9261034e565b610361565b604051908152f35b60046040517f37766e12000000000000000000000000000000000000000000000000000000008152fd5b905061006d565b5f80fd5b346100f9576100bb61016b61015161017973ffffffffffffffffffffffffffffffffffffffff6100ab6100b0610173610165610138366101d4565b608093909352909d96509081019450925061028c915050565b929a849f969e9599949a92979197166103af565b956102ea565b60805161034e565b956104f2565b908082101561019f57505b81116100c8578161019a6020936100c093610361565b61034e565b9050610184565b9181601f840112156100f95782359167ffffffffffffffff83116100f957602083818601950101116100f957565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82016101c081126100f957610100136100f95760049167ffffffffffffffff90610104358281116100f9578161022e916004016101a6565b9390939261012435926101443573ffffffffffffffffffffffffffffffffffffffff811681036100f95792610164359261018435926101a4359182116100f95761027a916004016101a6565b9091565b359060ff821682036100f957565b908160e09103126100f957803591602082013591604081013591606082013591608081013573ffffffffffffffffffffffffffffffffffffffff811681036100f957916102e760c06102e060a0850161027e565b930161027e565b90565b60ff60089116019060ff82116102fc57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b9060ff8091169116039060ff82116102fc57565b60ff16604d81116102fc57600a0a90565b818102929181159184041417156102fc57565b811561036b570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b519069ffffffffffffffffffff821682036100f957565b60a073ffffffffffffffffffffffffffffffffffffffff916004604051809481937ffeaf968c000000000000000000000000000000000000000000000000000000008352165afa9081156104e7575f91610439575b505f8113156104105790565b60046040517ebfc921000000000000000000000000000000000000000000000000000000008152fd5b905060a03d60a0116104e0575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f820116820182811067ffffffffffffffff8211176104b35760a0918391604052810103126100f95761049a81610398565b506104ac608060208301519201610398565b505f610404565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d610446565b6040513d5f823e3d90fd5b9190918042106105235742034281116102fc576105129261019a91610361565b8181111561051e575090565b905090565b505050505f9056fea26469706673582212205d1799482a35108cfd83d52f20ed2dd4c9e717f1eaa56caaaaed8b497264250864736f6c63430008170033",
  "deployedBytecode": "0x60a06040526004361015610011575f80fd5b5f3560e01c80631d9671c3146100fd5763d7ff8a801461002f575f80fd5b346100f957610056610062610043366101d4565b945094509695509693505081019061028c565b979490969391956104f2565b90808210156100f257505b84116100c8576020936100b56100b06100c0956100ab6100a573ffffffffffffffffffffffffffffffffffffffff6100bb97166103af565b966102ea565b610329565b61033d565b9261034e565b610361565b604051908152f35b60046040517f37766e12000000000000000000000000000000000000000000000000000000008152fd5b905061006d565b5f80fd5b346100f9576100bb61016b61015161017973ffffffffffffffffffffffffffffffffffffffff6100ab6100b0610173610165610138366101d4565b608093909352909d96509081019450925061028c915050565b929a849f969e9599949a92979197166103af565b956102ea565b60805161034e565b956104f2565b908082101561019f57505b81116100c8578161019a6020936100c093610361565b61034e565b9050610184565b9181601f840112156100f95782359167ffffffffffffffff83116100f957602083818601950101116100f957565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82016101c081126100f957610100136100f95760049167ffffffffffffffff90610104358281116100f9578161022e916004016101a6565b9390939261012435926101443573ffffffffffffffffffffffffffffffffffffffff811681036100f95792610164359261018435926101a4359182116100f95761027a916004016101a6565b9091565b359060ff821682036100f957565b908160e09103126100f957803591602082013591604081013591606082013591608081013573ffffffffffffffffffffffffffffffffffffffff811681036100f957916102e760c06102e060a0850161027e565b930161027e565b90565b60ff60089116019060ff82116102fc57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b9060ff8091169116039060ff82116102fc57565b60ff16604d81116102fc57600a0a90565b818102929181159184041417156102fc57565b811561036b570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b519069ffffffffffffffffffff821682036100f957565b60a073ffffffffffffffffffffffffffffffffffffffff916004604051809481937ffeaf968c000000000000000000000000000000000000000000000000000000008352165afa9081156104e7575f91610439575b505f8113156104105790565b60046040517ebfc921000000000000000000000000000000000000000000000000000000008152fd5b905060a03d60a0116104e0575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f820116820182811067ffffffffffffffff8211176104b35760a0918391604052810103126100f95761049a81610398565b506104ac608060208301519201610398565b505f610404565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d610446565b6040513d5f823e3d90fd5b9190918042106105235742034281116102fc576105129261019a91610361565b8181111561051e575090565b905090565b505050505f9056fea26469706673582212205d1799482a35108cfd83d52f20ed2dd4c9e717f1eaa56caaaaed8b497264250864736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "title": "TWAPCalculator",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getMakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)": {
        "notice": "Called by Fusion to calculate how much makerAsset can be bought for a given takerAsset amount"
      },
      "getTakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)": {
        "notice": "Called by Fusion to calculate the takerAsset amount required for a given makerAsset amount"
      }
    },
    "notice": "Calculates time-unlocked makerAsset amounts with real-time pricing via Chainlink.         Fully Fusion-compatible and supports arbitrary token decimals via extraData.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}