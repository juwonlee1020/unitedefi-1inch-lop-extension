{
  "address": "0x14835B093D320AA5c9806BBC64C17F0F2546D9EE",
  "abi": [
    {
      "inputs": [],
      "name": "InvalidPrice",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RequestedExceedsUnlocked",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "decodeExtraData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "interval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "chunkAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "priceFeed",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "makerDecimals",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "takerDecimals",
          "type": "uint8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "takingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingMakingAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "getMakingAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "makerAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "salt",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "maker",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "receiver",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "makerAsset",
              "type": "uint256"
            },
            {
              "internalType": "Address",
              "name": "takerAsset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "makingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takingAmount",
              "type": "uint256"
            },
            {
              "internalType": "MakerTraits",
              "name": "makerTraits",
              "type": "uint256"
            }
          ],
          "internalType": "struct IOrderMixin.Order",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "makingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingMakingAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "extraData",
          "type": "bytes"
        }
      ],
      "name": "getTakingAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "takerAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x902b6adc7154f9c79cd9be003cf3b009116c1d5698fadeafa24b6b3c7906166d",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x14835B093D320AA5c9806BBC64C17F0F2546D9EE",
    "transactionIndex": 0,
    "gasUsed": "372544",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5cc49d42d6a72b74c9a200f240d26021dda3857e70dd81e88e2a24c1204f78db",
    "transactionHash": "0x902b6adc7154f9c79cd9be003cf3b009116c1d5698fadeafa24b6b3c7906166d",
    "logs": [],
    "blockNumber": 23029352,
    "cumulativeGasUsed": "372544",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "5686439602e91d2479da7918032867c0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestedExceedsUnlocked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"decodeExtraData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chunkAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"makerDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"takerDecimals\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingMakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"getMakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"makerAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"maker\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"receiver\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"makerAsset\",\"type\":\"uint256\"},{\"internalType\":\"Address\",\"name\":\"takerAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"MakerTraits\",\"name\":\"makerTraits\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderMixin.Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingMakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"getTakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"takerAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"TWAPCalculator (Chunk-Based)\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"decodeExtraData(bytes)\":{\"notice\":\"Decode parameters from extraData\"},\"getMakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)\":{\"notice\":\"Called by Fusion to calculate how much makerAsset is given for a takerAsset amount\"},\"getTakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)\":{\"notice\":\"Called by Fusion to calculate takerAsset required for a given makingAmount\"}},\"notice\":\"Calculates fixed-interval unlocked amounts for makerAsset with Chainlink pricing.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/extensions/TWAPCalculator.sol\":\"TWAPCalculator\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype Address is uint256;\\n\\n/**\\n* @notice AddressLib\\n* @notice Library for working with addresses encoded as uint256 values, which can include flags in the highest bits.\\n*/\\nlibrary AddressLib {\\n    uint256 private constant _LOW_160_BIT_MASK = (1 << 160) - 1;\\n\\n    /**\\n    * @notice Returns the address representation of a uint256.\\n    * @param a The uint256 value to convert to an address.\\n    * @return The address representation of the provided uint256 value.\\n    */\\n    function get(Address a) internal pure returns (address) {\\n        return address(uint160(Address.unwrap(a) & _LOW_160_BIT_MASK));\\n    }\\n\\n    /**\\n    * @notice Checks if a given flag is set for the provided address.\\n    * @param a The address to check for the flag.\\n    * @param flag The flag to check for in the provided address.\\n    * @return True if the provided flag is set in the address, false otherwise.\\n    */\\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\\n        return (Address.unwrap(a) & flag) != 0;\\n    }\\n\\n    /**\\n    * @notice Returns a uint32 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint32 value.\\n    * @param offset The bit offset at which the uint32 value is stored.\\n    * @return The uint32 value stored in the address at the specified bit offset.\\n    */\\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\\n        return uint32(Address.unwrap(a) >> offset);\\n    }\\n\\n    /**\\n    * @notice Returns a uint64 value stored at a specific bit offset in the provided address.\\n    * @param a The address containing the uint64 value.\\n    * @param offset The bit offset at which the uint64 value is stored.\\n    * @return The uint64 value stored in the address at the specified bit offset.\\n    */\\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\\n        return uint64(Address.unwrap(a) >> offset);\\n    }\\n}\\n\",\"keccak256\":\"0xe860b410ed5371b9732daab80982eef0a42ae48474716a89725ca744e27b7d75\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0xfe4e8bb4861bb3860ba890ab91a3b818ec66e5a8f544fb608cfcb73f433472cd\",\"license\":\"MIT\"},\"contracts/extensions/TWAPCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/IAmountGetter.sol\\\";\\nimport \\\"../interfaces/IOrderMixin.sol\\\";\\n\\n/// @title TWAPCalculator (Chunk-Based)\\n/// @notice Calculates fixed-interval unlocked amounts for makerAsset with Chainlink pricing.\\ncontract TWAPCalculator is IAmountGetter {\\n    error RequestedExceedsUnlocked();\\n    error InvalidPrice();\\n\\n    /// @notice Decode parameters from extraData\\n    function decodeExtraData(bytes calldata extraData)\\n        external\\n        pure\\n        returns (\\n            uint256 startTime,\\n            uint256 interval,\\n            uint256 chunkAmount,\\n            address priceFeed,\\n            uint8 makerDecimals,\\n            uint8 takerDecimals\\n        )\\n    {\\n        return abi.decode(extraData, (uint256, uint256, uint256, address, uint8, uint8));\\n    }\\n\\n    /// @notice Called by Fusion to calculate takerAsset required for a given makingAmount\\n    function getTakingAmount(\\n        IOrderMixin.Order calldata, // order (unused)\\n        bytes calldata,             // extension (unused)\\n        bytes32,                    // orderHash (unused)\\n        address,                    // taker (unused)\\n        uint256 makingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view override returns (uint256 takerAmount) {\\n        (\\n            uint256 startTime,\\n            uint256 interval,\\n            uint256 chunkAmount,\\n            address priceFeed,\\n            uint8 makerDecimals,\\n            uint8 takerDecimals\\n        ) = abi.decode(extraData, (uint256, uint256, uint256, address, uint8, uint8));\\n\\n        uint256 unlocked = _getUnlockedAmount(startTime, interval, chunkAmount, remainingMakingAmount);\\n        if (makingAmount > unlocked) revert RequestedExceedsUnlocked();\\n\\n        uint256 price = _getLatestPrice(priceFeed); // 8 decimals from Chainlink\\n        uint256 scale = 10 ** (makerDecimals + 8 - takerDecimals); // normalize to target decimals\\n        takerAmount = price * makingAmount / scale;\\n    }\\n\\n    /// @notice Called by Fusion to calculate how much makerAsset is given for a takerAsset amount\\n    function getMakingAmount(\\n        IOrderMixin.Order calldata, // order (unused)\\n        bytes calldata,             // extension (unused)\\n        bytes32,                    // orderHash (unused)\\n        address,                    // taker (unused)\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view override returns (uint256 makerAmount) {\\n        (\\n            uint256 startTime,\\n            uint256 interval,\\n            uint256 chunkAmount,\\n            address priceFeed,\\n            uint8 makerDecimals,\\n            uint8 takerDecimals\\n        ) = abi.decode(extraData, (uint256, uint256, uint256, address, uint8, uint8));\\n\\n        uint256 price = _getLatestPrice(priceFeed); // Chainlink: 8 decimals\\n        uint256 scale = 10 ** (makerDecimals + 8 - takerDecimals);\\n        makerAmount = takingAmount * scale / price;\\n\\n        uint256 unlocked = _getUnlockedAmount(startTime, interval, chunkAmount, remainingMakingAmount);\\n        if (makerAmount > unlocked) revert RequestedExceedsUnlocked();\\n\\n        // Round down to nearest full chunk\\n        uint256 chunks = makerAmount / chunkAmount;\\n        makerAmount = chunks * chunkAmount;\\n    }\\n\\n    /// @dev Internal: Calculates how much makerAsset is unlocked at current time\\n    function _getUnlockedAmount(\\n        uint256 startTime,\\n        uint256 interval,\\n        uint256 chunkAmount,\\n        uint256 remaining\\n    ) internal view returns (uint256) {\\n        if (block.timestamp < startTime) return 0;\\n\\n        uint256 elapsed = block.timestamp - startTime;\\n        uint256 chunksUnlocked = elapsed / interval;\\n        uint256 unlocked = chunksUnlocked * chunkAmount;\\n\\n        return unlocked > remaining ? remaining : unlocked;\\n    }\\n\\n    /// @dev Internal: Fetch latest Chainlink price (8 decimals)\\n    function _getLatestPrice(address priceFeed) internal view returns (uint256) {\\n        (, int256 price,,,) = AggregatorV3Interface(priceFeed).latestRoundData();\\n        if (price <= 0) revert InvalidPrice();\\n        return uint256(price);\\n    }\\n}\\n\",\"keccak256\":\"0xaeb97b9d14158c9107a49a8c743dd30139e26c436828028602e3c0d7bf3f9c68\",\"license\":\"MIT\"},\"contracts/interfaces/IAmountGetter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOrderMixin.sol\\\";\\n\\n/**\\n * @title IAmountGetter\\n * @notice Interface for external logic to determine actual making and taking amounts for orders.\\n */\\ninterface IAmountGetter {\\n    /**\\n     * @notice View method that gets called to determine the actual making amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param takingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return makingAmount Actual making amount that should be used for the order\\n     */\\n    function getMakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 takingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice View method that gets called to determine the actual taking amount\\n     * @param order Order being processed\\n     * @param extension Order extension data\\n     * @param orderHash Hash of the order being processed\\n     * @param taker Taker address\\n     * @param makingAmount Actual taking amount\\n     * @param remainingMakingAmount Order remaining making amount\\n     * @param extraData Extra data\\n     * @return takingAmount Actual taking amount that should be used for the order\\n     */\\n    function getTakingAmount(\\n        IOrderMixin.Order calldata order,\\n        bytes calldata extension,\\n        bytes32 orderHash,\\n        address taker,\\n        uint256 makingAmount,\\n        uint256 remainingMakingAmount,\\n        bytes calldata extraData\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd2f5f477d812411a2eee26d645cd096b256221862fcf4a004128f7bdd43a6e08\",\"license\":\"MIT\"},\"contracts/interfaces/IOrderMixin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@1inch/solidity-utils/contracts/libraries/AddressLib.sol\\\";\\nimport \\\"../libraries/MakerTraitsLib.sol\\\";\\nimport \\\"../libraries/TakerTraitsLib.sol\\\";\\n\\n/**\\n * @title IOrderMixin\\n * @notice Interface for order processing logic in the 1inch Limit Order Protocol.\\n */\\ninterface IOrderMixin {\\n    struct Order {\\n        uint256 salt;\\n        Address maker;\\n        Address receiver;\\n        Address makerAsset;\\n        Address takerAsset;\\n        uint256 makingAmount;\\n        uint256 takingAmount;\\n        MakerTraits makerTraits;\\n    }\\n\\n    error InvalidatedOrder();\\n    error TakingAmountExceeded();\\n    error PrivateOrder();\\n    error BadSignature();\\n    error OrderExpired();\\n    error WrongSeriesNonce();\\n    error SwapWithZeroAmount();\\n    error PartialFillNotAllowed();\\n    error OrderIsNotSuitableForMassInvalidation();\\n    error EpochManagerAndBitInvalidatorsAreIncompatible();\\n    error ReentrancyDetected();\\n    error PredicateIsNotTrue();\\n    error TakingAmountTooHigh();\\n    error MakingAmountTooLow();\\n    error TransferFromMakerToTakerFailed();\\n    error TransferFromTakerToMakerFailed();\\n    error MismatchArraysLengths();\\n    error InvalidPermit2Transfer();\\n    error SimulationResults(bool success, bytes res);\\n\\n    /**\\n     * @notice Emitted when order gets filled\\n     * @param orderHash Hash of the order\\n     * @param remainingAmount Amount of the maker asset that remains to be filled\\n     */\\n    event OrderFilled(\\n        bytes32 orderHash,\\n        uint256 remainingAmount\\n    );\\n\\n    /**\\n     * @notice Emitted when order without `useBitInvalidator` gets cancelled\\n     * @param orderHash Hash of the order\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash\\n    );\\n\\n    /**\\n     * @notice Emitted when order with `useBitInvalidator` gets cancelled\\n     * @param maker Maker address\\n     * @param slotIndex Slot index that was updated\\n     * @param slotValue New slot value\\n     */\\n    event BitInvalidatorUpdated(\\n        address indexed maker,\\n        uint256 slotIndex,\\n        uint256 slotValue\\n    );\\n\\n    /**\\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\\n     * @dev The function always reverts and returns the simulation results in revert data.\\n     * @param target Addresses that will be delegated\\n     * @param data Data that will be passed to delegatee\\n     */\\n    function simulate(address target, bytes calldata data) external;\\n\\n    /**\\n     * @notice Cancels order's quote\\n     * @param makerTraits Order makerTraits\\n     * @param orderHash Hash of the order to cancel\\n     */\\n    function cancelOrder(MakerTraits makerTraits, bytes32 orderHash) external;\\n\\n    /**\\n     * @notice Cancels orders' quotes\\n     * @param makerTraits Orders makerTraits\\n     * @param orderHashes Hashes of the orders to cancel\\n     */\\n    function cancelOrders(MakerTraits[] calldata makerTraits, bytes32[] calldata orderHashes) external;\\n\\n    /**\\n     * @notice Cancels all quotes of the maker (works for bit-invalidating orders only)\\n     * @param makerTraits Order makerTraits\\n     * @param additionalMask Additional bitmask to invalidate orders\\n     */\\n    function bitsInvalidateForOrder(MakerTraits makerTraits, uint256 additionalMask) external;\\n\\n    /**\\n     * @notice Fills order's quote, fully or partially (whichever is possible).\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrder(\\n        Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param r R component of signature\\n     * @param vs VS component of signature\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     */\\n    function fillOrderArgs(\\n        IOrderMixin.Order calldata order,\\n        bytes32 r,\\n        bytes32 vs,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external payable returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillOrder` but uses contract-based signatures.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrder(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Same as `fillContractOrder` but allows to specify arguments that are used by the taker.\\n     * @param order Order quote to fill\\n     * @param signature Signature to confirm quote ownership\\n     * @param amount Taker amount to fill\\n     * @param takerTraits Specifies threshold as maximum allowed takingAmount when takingAmount is zero, otherwise specifies\\n     * minimum allowed makingAmount. The 2nd (0 based index) highest bit specifies whether taker wants to skip maker's permit.\\n     * @param args Arguments that are used by the taker (target, extension, interaction, permit)\\n     * @return makingAmount Actual amount transferred from maker to taker\\n     * @return takingAmount Actual amount transferred from taker to maker\\n     * @return orderHash Hash of the filled order\\n     * @dev See tests for examples\\n     */\\n    function fillContractOrderArgs(\\n        Order calldata order,\\n        bytes calldata signature,\\n        uint256 amount,\\n        TakerTraits takerTraits,\\n        bytes calldata args\\n    ) external returns(uint256 makingAmount, uint256 takingAmount, bytes32 orderHash);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param maker Maker address\\n     * @param slot Slot number to return bitmask for\\n     * @return result Each bit represents whether corresponding was already invalidated\\n     */\\n    function bitInvalidatorForOrder(address maker, uint256 slot) external view returns(uint256 result);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remaining Remaining amount of the order\\n     */\\n    function remainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remaining);\\n\\n    /**\\n     * @notice Returns bitmask for double-spend invalidators based on lowest byte of order.info and filled quotes\\n     * @param orderHash Hash of the order\\n     * @return remainingRaw Inverse of the remaining amount of the order if order was filled at least once, otherwise 0\\n     */\\n    function rawRemainingInvalidatorForOrder(address maker, bytes32 orderHash) external view returns(uint256 remainingRaw);\\n\\n    /**\\n     * @notice Returns order hash, hashed with limit order protocol contract EIP712\\n     * @param order Order\\n     * @return orderHash Hash of the order\\n     */\\n    function hashOrder(IOrderMixin.Order calldata order) external view returns(bytes32 orderHash);\\n}\\n\",\"keccak256\":\"0x39cfb84ae74a276eae63d7b3be898104045f98163405190227ddae3e85f6dd11\",\"license\":\"MIT\"},\"contracts/libraries/MakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype MakerTraits is uint256;\\n\\n/**\\n * @title MakerTraitsLib\\n * @notice A library to manage and check MakerTraits, which are used to encode the maker's preferences for an order in a single uint256.\\n * @dev\\n * The MakerTraits type is a uint256 and different parts of the number are used to encode different traits.\\n * High bits are used for flags\\n * 255 bit `NO_PARTIAL_FILLS_FLAG`          - if set, the order does not allow partial fills\\n * 254 bit `ALLOW_MULTIPLE_FILLS_FLAG`      - if set, the order permits multiple fills\\n * 253 bit                                  - unused\\n * 252 bit `PRE_INTERACTION_CALL_FLAG`      - if set, the order requires pre-interaction call\\n * 251 bit `POST_INTERACTION_CALL_FLAG`     - if set, the order requires post-interaction call\\n * 250 bit `NEED_CHECK_EPOCH_MANAGER_FLAG`  - if set, the order requires to check the epoch manager\\n * 249 bit `HAS_EXTENSION_FLAG`             - if set, the order has extension(s)\\n * 248 bit `USE_PERMIT2_FLAG`               - if set, the order uses permit2\\n * 247 bit `UNWRAP_WETH_FLAG`               - if set, the order requires to unwrap WETH\\n\\n * Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n * uint80 last 10 bytes of allowed sender address (0 if any)\\n * uint40 expiration timestamp (0 if none)\\n * uint40 nonce or epoch\\n * uint40 series\\n */\\nlibrary MakerTraitsLib {\\n    // Low 200 bits are used for allowed sender, expiration, nonceOrEpoch, and series\\n    uint256 private constant _ALLOWED_SENDER_MASK = type(uint80).max;\\n    uint256 private constant _EXPIRATION_OFFSET = 80;\\n    uint256 private constant _EXPIRATION_MASK = type(uint40).max;\\n    uint256 private constant _NONCE_OR_EPOCH_OFFSET = 120;\\n    uint256 private constant _NONCE_OR_EPOCH_MASK = type(uint40).max;\\n    uint256 private constant _SERIES_OFFSET = 160;\\n    uint256 private constant _SERIES_MASK = type(uint40).max;\\n\\n    uint256 private constant _NO_PARTIAL_FILLS_FLAG = 1 << 255;\\n    uint256 private constant _ALLOW_MULTIPLE_FILLS_FLAG = 1 << 254;\\n    uint256 private constant _PRE_INTERACTION_CALL_FLAG = 1 << 252;\\n    uint256 private constant _POST_INTERACTION_CALL_FLAG = 1 << 251;\\n    uint256 private constant _NEED_CHECK_EPOCH_MANAGER_FLAG = 1 << 250;\\n    uint256 private constant _HAS_EXTENSION_FLAG = 1 << 249;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 248;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 247;\\n\\n    /**\\n     * @notice Checks if the order has the extension flag set.\\n     * @dev If the `HAS_EXTENSION_FLAG` is set in the makerTraits, then the protocol expects that the order has extension(s).\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the flag is set.\\n     */\\n    function hasExtension(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _HAS_EXTENSION_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker allows a specific taker to fill the order.\\n     * @param makerTraits The traits of the maker.\\n     * @param sender The address of the taker to be checked.\\n     * @return result A boolean indicating whether the taker is allowed.\\n     */\\n    function isAllowedSender(MakerTraits makerTraits, address sender) internal pure returns (bool) {\\n        uint160 allowedSender = uint160(MakerTraits.unwrap(makerTraits) & _ALLOWED_SENDER_MASK);\\n        return allowedSender == 0 || allowedSender == uint160(sender) & _ALLOWED_SENDER_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the expiration time of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The expiration timestamp of the order.\\n     */\\n    function getExpirationTime(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _EXPIRATION_OFFSET) & _EXPIRATION_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the order has expired.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the order has expired.\\n     */\\n    function isExpired(MakerTraits makerTraits) internal view returns (bool) {\\n        uint256 expiration = getExpirationTime(makerTraits);\\n        return expiration != 0 && expiration < block.timestamp;  // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /**\\n     * @notice Returns the nonce or epoch of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The nonce or epoch of the order.\\n     */\\n    function nonceOrEpoch(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _NONCE_OR_EPOCH_OFFSET) & _NONCE_OR_EPOCH_MASK;\\n    }\\n\\n    /**\\n     * @notice Returns the series of the order.\\n     * @param makerTraits The traits of the maker.\\n     * @return result The series of the order.\\n     */\\n    function series(MakerTraits makerTraits) internal pure returns (uint256) {\\n        return (MakerTraits.unwrap(makerTraits) >> _SERIES_OFFSET) & _SERIES_MASK;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows partial fills.\\n      * @dev If the _NO_PARTIAL_FILLS_FLAG is not set in the makerTraits, then the order allows partial fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows partial fills.\\n      */\\n    function allowPartialFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NO_PARTIAL_FILLS_FLAG) == 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs pre-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a pre-interaction call.\\n     */\\n    function needPreInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _PRE_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs post-interaction call.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs a post-interaction call.\\n     */\\n    function needPostInteractionCall(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _POST_INTERACTION_CALL_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if the order allows multiple fills.\\n      * @dev If the _ALLOW_MULTIPLE_FILLS_FLAG is set in the makerTraits, then the maker allows multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the maker allows multiple fills.\\n      */\\n    function allowMultipleFills(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _ALLOW_MULTIPLE_FILLS_FLAG) != 0;\\n    }\\n\\n    /**\\n      * @notice Determines if an order should use the bit invalidator or remaining amount validator.\\n      * @dev The bit invalidator can be used if the order does not allow partial or multiple fills.\\n      * @param makerTraits The traits of the maker, determining their preferences for the order.\\n      * @return result A boolean indicating whether the bit invalidator should be used.\\n      * True if the order requires the use of the bit invalidator.\\n      */\\n    function useBitInvalidator(MakerTraits makerTraits) internal pure returns (bool) {\\n        return !allowPartialFills(makerTraits) || !allowMultipleFills(makerTraits);\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to check the epoch.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to check the epoch manager.\\n     */\\n    function needCheckEpochManager(MakerTraits makerTraits) internal pure returns (bool) {\\n        return (MakerTraits.unwrap(makerTraits) & _NEED_CHECK_EPOCH_MANAGER_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker uses permit2.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker uses permit2.\\n     */\\n    function usePermit2(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _USE_PERMIT2_FLAG != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the maker needs to unwraps WETH.\\n     * @param makerTraits The traits of the maker.\\n     * @return result A boolean indicating whether the maker needs to unwrap WETH.\\n     */\\n    function unwrapWeth(MakerTraits makerTraits) internal pure returns (bool) {\\n        return MakerTraits.unwrap(makerTraits) & _UNWRAP_WETH_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0x9506febc99293a286356a03cb150ad82ccb88be1b4c908183e1273b41fcb902c\",\"license\":\"MIT\"},\"contracts/libraries/TakerTraitsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ntype TakerTraits is uint256;\\n\\n/**\\n * @title TakerTraitsLib\\n * @notice This library to manage and check TakerTraits, which are used to encode the taker's preferences for an order in a single uint256.\\n * @dev The TakerTraits are structured as follows:\\n * High bits are used for flags\\n * 255 bit `_MAKER_AMOUNT_FLAG`           - If set, the taking amount is calculated based on making amount, otherwise making amount is calculated based on taking amount.\\n * 254 bit `_UNWRAP_WETH_FLAG`            - If set, the WETH will be unwrapped into ETH before sending to taker.\\n * 253 bit `_SKIP_ORDER_PERMIT_FLAG`      - If set, the order skips maker's permit execution.\\n * 252 bit `_USE_PERMIT2_FLAG`            - If set, the order uses the permit2 function for authorization.\\n * 251 bit `_ARGS_HAS_TARGET`             - If set, then first 20 bytes of args are treated as target address for maker\\u2019s funds transfer.\\n * 224-247 bits `ARGS_EXTENSION_LENGTH`   - The length of the extension calldata in the args.\\n * 200-223 bits `ARGS_INTERACTION_LENGTH` - The length of the interaction calldata in the args.\\n * 0-184 bits                             - The threshold amount (the maximum amount a taker agrees to give in exchange for a making amount).\\n */\\nlibrary TakerTraitsLib {\\n    uint256 private constant _MAKER_AMOUNT_FLAG = 1 << 255;\\n    uint256 private constant _UNWRAP_WETH_FLAG = 1 << 254;\\n    uint256 private constant _SKIP_ORDER_PERMIT_FLAG = 1 << 253;\\n    uint256 private constant _USE_PERMIT2_FLAG = 1 << 252;\\n    uint256 private constant _ARGS_HAS_TARGET = 1 << 251;\\n\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_OFFSET = 224;\\n    uint256 private constant _ARGS_EXTENSION_LENGTH_MASK = 0xffffff;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_OFFSET = 200;\\n    uint256 private constant _ARGS_INTERACTION_LENGTH_MASK = 0xffffff;\\n\\n    uint256 private constant _AMOUNT_MASK = 0x000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Checks if the args should contain target address.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the args should contain target address.\\n     */\\n    function argsHasTarget(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _ARGS_HAS_TARGET) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the extension calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the extension calldata encoded in the takerTraits.\\n     */\\n    function argsExtensionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_EXTENSION_LENGTH_OFFSET) & _ARGS_EXTENSION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Retrieves the length of the interaction calldata from the takerTraits.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The length of the interaction calldata encoded in the takerTraits.\\n     */\\n    function argsInteractionLength(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return (TakerTraits.unwrap(takerTraits) >> _ARGS_INTERACTION_LENGTH_OFFSET) & _ARGS_INTERACTION_LENGTH_MASK;\\n    }\\n\\n    /**\\n     * @notice Checks if the taking amount should be calculated based on making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the taking amount should be calculated based on making amount.\\n     */\\n    function isMakingAmount(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _MAKER_AMOUNT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should unwrap WETH and send ETH to taker.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order should unwrap WETH.\\n     */\\n    function unwrapWeth(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _UNWRAP_WETH_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order should skip maker's permit execution.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order don't apply permit.\\n     */\\n    function skipMakerPermit(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _SKIP_ORDER_PERMIT_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Checks if the order uses the permit2 instead of permit.\\n     * @param takerTraits The traits of the taker.\\n     * @return result A boolean indicating whether the order uses the permit2.\\n     */\\n    function usePermit2(TakerTraits takerTraits) internal pure returns (bool) {\\n        return (TakerTraits.unwrap(takerTraits) & _USE_PERMIT2_FLAG) != 0;\\n    }\\n\\n    /**\\n     * @notice Retrieves the threshold amount from the takerTraits.\\n     * The maximum amount a taker agrees to give in exchange for a making amount.\\n     * @param takerTraits The traits of the taker.\\n     * @return result The threshold amount encoded in the takerTraits.\\n     */\\n    function threshold(TakerTraits takerTraits) internal pure returns (uint256) {\\n        return TakerTraits.unwrap(takerTraits) & _AMOUNT_MASK;\\n    }\\n}\\n\",\"keccak256\":\"0x144f154a46e8daa0fec5b8215f1d8d3b694cb939236aa7bf89976b27965c2837\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234610016576105cf908161001b8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c80631d9671c3146101935780635ef271c6146100f55763d7ff8a801461003a575f80fd5b346100f15761006061006c61004e36610247565b945094509550969350508101906102ff565b96939095929194610560565b84116100c7576020936100b46100af6100bf956100aa6100a473ffffffffffffffffffffffffffffffffffffffff6100ba971661041d565b96610358565b610397565b6103ab565b926103bc565b6103cf565b604051908152f35b60046040517f37766e12000000000000000000000000000000000000000000000000000000008152fd5b5f80fd5b346100f15760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100f15760043567ffffffffffffffff81116100f15773ffffffffffffffffffffffffffffffffffffffff60ff8061016961016160c0953690600401610219565b8101906102ff565b959497929093604051988952602089015260408801521660608601521660808401521660a0820152f35b346100f15773ffffffffffffffffffffffffffffffffffffffff6100af6101fe6101e06101f26100aa6101f86100a46100ba6101ce36610247565b945094509b94509450508101906102ff565b929e8f9b959e949a929891981661041d565b906103bc565b94610560565b81116100c757816102146020936100bf936103cf565b6103bc565b9181601f840112156100f15782359167ffffffffffffffff83116100f157602083818601950101116100f157565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82016101c081126100f157610100136100f15760049167ffffffffffffffff90610104358281116100f157816102a191600401610219565b9390939261012435926101443573ffffffffffffffffffffffffffffffffffffffff811681036100f15792610164359261018435926101a4359182116100f1576102ed91600401610219565b9091565b359060ff821682036100f157565b91908260c09103126100f157813591602081013591604082013591606081013573ffffffffffffffffffffffffffffffffffffffff811681036100f1579161035560a061034e608085016102f1565b93016102f1565b90565b60ff60089116019060ff821161036a57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b9060ff8091169116039060ff821161036a57565b60ff16604d811161036a57600a0a90565b8181029291811591840414171561036a57565b81156103d9570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b519069ffffffffffffffffffff821682036100f157565b60a073ffffffffffffffffffffffffffffffffffffffff916004604051809481937ffeaf968c000000000000000000000000000000000000000000000000000000008352165afa908115610555575f916104a7575b505f81131561047e5790565b60046040517ebfc921000000000000000000000000000000000000000000000000000000008152fd5b905060a03d60a01161054e575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f820116820182811067ffffffffffffffff8211176105215760a0918391604052810103126100f15761050881610406565b5061051a608060208301519201610406565b505f610472565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d6104b4565b6040513d5f823e3d90fd5b91909180421061059157420342811161036a5761058092610214916103cf565b8181111561058c575090565b905090565b505050505f9056fea2646970667358221220e1775e36b4e173f45a60e1fd2b1dc33f96c6b45ef5ca4a88ba745b3b84e3a9b264736f6c63430008170033",
  "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c80631d9671c3146101935780635ef271c6146100f55763d7ff8a801461003a575f80fd5b346100f15761006061006c61004e36610247565b945094509550969350508101906102ff565b96939095929194610560565b84116100c7576020936100b46100af6100bf956100aa6100a473ffffffffffffffffffffffffffffffffffffffff6100ba971661041d565b96610358565b610397565b6103ab565b926103bc565b6103cf565b604051908152f35b60046040517f37766e12000000000000000000000000000000000000000000000000000000008152fd5b5f80fd5b346100f15760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100f15760043567ffffffffffffffff81116100f15773ffffffffffffffffffffffffffffffffffffffff60ff8061016961016160c0953690600401610219565b8101906102ff565b959497929093604051988952602089015260408801521660608601521660808401521660a0820152f35b346100f15773ffffffffffffffffffffffffffffffffffffffff6100af6101fe6101e06101f26100aa6101f86100a46100ba6101ce36610247565b945094509b94509450508101906102ff565b929e8f9b959e949a929891981661041d565b906103bc565b94610560565b81116100c757816102146020936100bf936103cf565b6103bc565b9181601f840112156100f15782359167ffffffffffffffff83116100f157602083818601950101116100f157565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82016101c081126100f157610100136100f15760049167ffffffffffffffff90610104358281116100f157816102a191600401610219565b9390939261012435926101443573ffffffffffffffffffffffffffffffffffffffff811681036100f15792610164359261018435926101a4359182116100f1576102ed91600401610219565b9091565b359060ff821682036100f157565b91908260c09103126100f157813591602081013591604082013591606081013573ffffffffffffffffffffffffffffffffffffffff811681036100f1579161035560a061034e608085016102f1565b93016102f1565b90565b60ff60089116019060ff821161036a57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b9060ff8091169116039060ff821161036a57565b60ff16604d811161036a57600a0a90565b8181029291811591840414171561036a57565b81156103d9570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b519069ffffffffffffffffffff821682036100f157565b60a073ffffffffffffffffffffffffffffffffffffffff916004604051809481937ffeaf968c000000000000000000000000000000000000000000000000000000008352165afa908115610555575f916104a7575b505f81131561047e5790565b60046040517ebfc921000000000000000000000000000000000000000000000000000000008152fd5b905060a03d60a01161054e575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f820116820182811067ffffffffffffffff8211176105215760a0918391604052810103126100f15761050881610406565b5061051a608060208301519201610406565b505f610472565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d6104b4565b6040513d5f823e3d90fd5b91909180421061059157420342811161036a5761058092610214916103cf565b8181111561058c575090565b905090565b505050505f9056fea2646970667358221220e1775e36b4e173f45a60e1fd2b1dc33f96c6b45ef5ca4a88ba745b3b84e3a9b264736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "title": "TWAPCalculator (Chunk-Based)",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "decodeExtraData(bytes)": {
        "notice": "Decode parameters from extraData"
      },
      "getMakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)": {
        "notice": "Called by Fusion to calculate how much makerAsset is given for a takerAsset amount"
      },
      "getTakingAmount((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),bytes,bytes32,address,uint256,uint256,bytes)": {
        "notice": "Called by Fusion to calculate takerAsset required for a given makingAmount"
      }
    },
    "notice": "Calculates fixed-interval unlocked amounts for makerAsset with Chainlink pricing.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}